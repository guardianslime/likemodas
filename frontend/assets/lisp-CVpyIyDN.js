import{b as e}from"./chunk-D0jsGFqN.js";var t=e(((exports,t)=>{t.exports=n,n.displayName=`lisp`,n.aliases=[];function n(e){(function(e){function t(e){return RegExp(/(\()/.source+`(?:`+e+`)`+/(?=[\s\)])/.source)}function n(e){return RegExp(/([\s([])/.source+`(?:`+e+`)`+/(?=[\s)])/.source)}var r=/(?!\d)[-+*/~!@$%^=<>{}\w]+/.source,i=`&`+r,a=`(\\()`,o=`(?=\\))`,s=`(?=\\s)`,c=/(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/.source,l={heading:{pattern:/;;;.*/,alias:[`comment`,`title`]},comment:/;.*/,string:{pattern:/"(?:[^"\\]|\\.)*"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\s])/,symbol:RegExp("`"+r+`'`)}},"quoted-symbol":{pattern:RegExp(`#?'`+r),alias:[`variable`,`symbol`]},"lisp-property":{pattern:RegExp(`:`+r),alias:`property`},splice:{pattern:RegExp(`,@?`+r),alias:[`symbol`,`variable`]},keyword:[{pattern:RegExp(a+`(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)`+s),lookbehind:!0},{pattern:RegExp(a+`(?:append|by|collect|concat|do|finally|for|in|return)`+s),lookbehind:!0}],declare:{pattern:t(/declare/.source),lookbehind:!0,alias:`keyword`},interactive:{pattern:t(/interactive/.source),lookbehind:!0,alias:`keyword`},boolean:{pattern:n(/nil|t/.source),lookbehind:!0},number:{pattern:n(/[-+]?\d+(?:\.\d*)?/.source),lookbehind:!0},defvar:{pattern:RegExp(a+`def(?:const|custom|group|var)\\s+`+r),lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:RegExp(r)}},defun:{pattern:RegExp(a+/(?:cl-)?(?:defmacro|defun\*?)\s+/.source+r+/\s+\(/.source+c+/\)/.source),lookbehind:!0,greedy:!0,inside:{keyword:/^(?:cl-)?def\S+/,arguments:null,function:{pattern:RegExp(`(^\\s)`+r),lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(a+`lambda\\s+\\(\\s*(?:&?`+r+`(?:\\s+&?`+r+`)*\\s*)?\\)`),lookbehind:!0,greedy:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(a+r),lookbehind:!0},punctuation:[/(?:['`,]?\(|[)\[\]])/,{pattern:/(\s)\.(?=\s)/,lookbehind:!0}]},u={"lisp-marker":RegExp(i),varform:{pattern:RegExp(/\(/.source+r+/\s+(?=\S)/.source+c+/\)/.source),inside:l},argument:{pattern:RegExp(/(^|[\s(])/.source+r),lookbehind:!0,alias:`variable`},rest:l},d=`\\S+(?:\\s+\\S+)*`,f={pattern:RegExp(a+c+o),lookbehind:!0,inside:{"rest-vars":{pattern:RegExp(`&(?:body|rest)\\s+`+d),inside:u},"other-marker-vars":{pattern:RegExp(`&(?:aux|optional)\\s+`+d),inside:u},keys:{pattern:RegExp(`&key\\s+`+d+`(?:\\s+&allow-other-keys)?`),inside:u},argument:{pattern:RegExp(r),alias:`variable`},punctuation:/[()]/}};l.lambda.inside.arguments=f,l.defun.inside.arguments=e.util.clone(f),l.defun.inside.arguments.inside.sublist=f,e.languages.lisp=l,e.languages.elisp=l,e.languages.emacs=l,e.languages[`emacs-lisp`]=l})(e)}}));export default t();